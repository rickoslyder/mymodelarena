Okay, let's plan the implementation step by step.

<brainstorming>

**Overall Approach:**

The plan follows a logical progression, starting with project setup and backend foundations, moving to core frontend layout and shared components, then implementing features incrementally. Each feature generally follows a pattern: backend API/logic first, then frontend UI/interaction. Testing steps are integrated alongside feature development where appropriate for unit/integration tests, with E2E tests planned towards the end.

**Phase Breakdown:**

1.  **Project Setup & Configuration:** Initialize client/server projects, install dependencies, set up TS configs, basic environment variables, Git.
2.  **Backend Core:** Database schema (Prisma), basic server (Express), routing structure, core middleware (error handling, logging), DB connection.
3.  **Frontend Core:** Basic app shell (Vite/React), routing (react-router-dom), global styles, layout components (Sidebar, PageWrapper), core UI library/components setup (e.g., CSS Modules), API client setup (`lib/api.ts`), core state management setup (TanStack Query provider, Zustand store if needed).
4.  **Feature Implementation (Iterative):**
    * **Model Management:** Backend (CRUD API) -> Frontend (List, Form, API integration). Includes cost/token setup.
    * **Core Services:** Backend `LlmService` (basic completion), `TokenizerService`.
    * **Eval Generation:** Backend (API, generation logic) -> Frontend (Form, API call).
    * **Eval Management:** Backend (CRUD API for Evals, Questions, Tags) -> Frontend (List, Detail, Search/Filter, Edit Forms, Tagging UI).
    * **Eval Execution:** Backend (API, async execution logic, response saving) -> Frontend (Config UI, trigger run, basic progress display).
    * **Response Scoring:** Backend (API for manual/LLM scoring) -> Frontend (UI integration in results view, scoring config modals).
    * **Judge Mode:** Backend (API, judging logic) -> Frontend (Config UI, trigger judging, results display).
    * **Reporting:** Backend (Aggregation APIs) -> Frontend (Reporting page, tables, charts, leaderboard).
5.  **Testing:** Integrate unit/integration tests alongside relevant backend/frontend steps. Add E2E test implementation steps covering major workflows near the end.
6.  **Polish & Documentation:** Final review of UI/UX, error handling, loading states. Update README.

**Key Considerations:**

* **Atomicity:** Each step is designed to be small and focused, typically involving one primary task (e.g., setting up a route, creating a component, implementing a controller action). File limits (max 20) are respected.
* **Dependencies:** Steps are ordered based on dependencies (e.g., DB schema before API routes using it, shared components before feature components using them). Dependencies are explicitly listed.
* **User Instructions:** Included for manual tasks like `.env` setup or running migrations.
* **Error Handling/Validation:** Incorporated into backend controller steps and frontend interaction steps.
* **Async Operations:** Backend steps define async logic; frontend steps handle corresponding loading/error states.

</brainstorming>

---

# Implementation Plan

## Phase 1: Project Setup & Core Configuration

* [ ] Step 1: Initialize Project Structure & Git
    * **Task**: Create the root directory `mymodelarena`, initialize Git, create `client` and `server` subdirectories, and a basic `.gitignore` file.
    * **Files**:
        * `.gitignore`: Add common Node/React/OS files (e.g., `node_modules`, `.env`, `dist`, `*.db`, `*.log`).
        * `README.md`: Basic project title.
    * **Step Dependencies**: None
    * **User Instructions**: None

* [ ] Step 2: Setup Server Project (Node.js/Express/TypeScript)
    * **Task**: Navigate to `server/`, run `npm init -y`, install core dependencies (`express`, `typescript`, `ts-node`, `@types/express`, `@types/node`, `dotenv`, `nodemon`, `prisma`, `@prisma/client`), and initialize `tsconfig.json`.
    * **Files**:
        * `server/package.json`: Created/updated with dependencies.
        * `server/tsconfig.json`: Basic TS config (`target: ES2016`, `module: CommonJS`, `outDir: ./dist`, `rootDir: ./src`, `strict: true`, `esModuleInterop: true`).
    * **Step Dependencies**: Step 1
    * **User Instructions**: None

* [ ] Step 3: Setup Client Project (React/TypeScript/Vite)
    * **Task**: Navigate to `client/`, initialize a React TypeScript project using Vite (`npm create vite@latest . --template react-ts`), and install core dependencies (`react-router-dom`, `@tanstack/react-query`, `zustand`, `axios` or use native `Workspace`).
    * **Files**:
        * `client/package.json`: Created/updated with dependencies.
        * `client/tsconfig.json`: Generated by Vite.
        * `client/vite.config.ts`: Generated by Vite.
        * `client/src/`: Basic Vite React TS structure.
    * **Step Dependencies**: Step 1
    * **User Instructions**: None

* [ ] Step 4: Setup Environment Variables
    * **Task**: Create a `.env.example` file in the root directory outlining required server environment variables. Create the `.env` file for local development.
    * **Files**:
        * `.env.example`: Define `DATABASE_URL` (e.g., `DATABASE_URL="file:./server/src/db/dev.db"`) and placeholders for potential API keys (e.g., `OPENAI_API_KEY=""`, `ANTHROPIC_API_KEY=""`).
        * `.env`: (User created locally, gitignored) Copy of `.env.example` with actual values filled in for local dev.
    * **Step Dependencies**: Step 1
    * **User Instructions**: Create a `.env` file in the project root by copying `.env.example` and fill in the `DATABASE_URL`. Add any initial LLM API keys you plan to test with as separate environment variables (e.g., `MY_GPT4_KEY=sk-...`).

## Phase 2: Backend Core Setup

* [ ] Step 5: Define Prisma Schema
    * **Task**: Initialize Prisma (`npx prisma init --datasource-provider sqlite`) in `server/`. Define all models (`Model`, `Eval`, `Question`, `Tag`, `EvalTag`, `EvalRun`, `Response`, `Score`, `Judgment`) in `schema.prisma` according to the specification.
    * **Files**:
        * `server/prisma/schema.prisma`: Define all database models, fields, relations, and indices.
    * **Step Dependencies**: Step 2, Step 4 (for `DATABASE_URL`)
    * **User Instructions**: None

* [ ] Step 6: Run Initial Database Migration
    * **Task**: Generate and apply the initial database migration using Prisma Migrate. This creates the SQLite database file and tables based on the schema.
    * **Files**:
        * `server/prisma/migrations/.../migration.sql`: Generated migration file.
        * `server/src/db/dev.db`: Created SQLite database file (or named as per `DATABASE_URL`).
    * **Step Dependencies**: Step 5
    * **User Instructions**: Run `npx prisma migrate dev --name init` inside the `server` directory.

* [ ] Step 7: Generate Prisma Client
    * **Task**: Generate the Prisma Client library based on the schema.
    * **Files**:
        * `server/node_modules/@prisma/client/`: Generated client files.
    * **Step Dependencies**: Step 5
    * **User Instructions**: Run `npx prisma generate` inside the `server` directory (usually runs automatically after migrate dev, but good to ensure).

* [ ] Step 8: Setup Prisma Client Instance
    * **Task**: Create a reusable Prisma client instance for the application.
    * **Files**:
        * `server/src/db/prisma.ts`: Initialize and export `new PrismaClient()`.
    * **Step Dependencies**: Step 7
    * **User Instructions**: None

* [ ] Step 9: Basic Express Server Setup
    * **Task**: Create the main server file, setup basic Express app, include middleware for JSON parsing and URL encoding, add a basic health check route (`/api/health`). Load environment variables using `dotenv`.
    * **Files**:
        * `server/src/server.ts`: Initialize Express, use `express.json()`, `express.urlencoded({ extended: true })`, setup basic health check route, start listening on a port from env or default.
        * `server/src/config/index.ts`: Load and export environment variables (e.g., `PORT`).
    * **Step Dependencies**: Step 2, Step 4
    * **User Instructions**: Add `PORT=3001` (or another port) to your `.env` file.

* [ ] Step 10: Setup Basic Routing Structure
    * **Task**: Create a main router file (`index.ts`) to aggregate feature routes. Mount this main router in `server.ts`. Create placeholder route files for upcoming features.
    * **Files**:
        * `server/src/routes/index.ts`: Import and use feature routers (e.g., `modelsRouter`). Export the main router.
        * `server/src/routes/models.routes.ts`: Create placeholder router using `express.Router()`.
        * `server/src/routes/evals.routes.ts`: Placeholder router.
        * `server/src/routes/evalRuns.routes.ts`: Placeholder router.
        * `server/src/routes/reports.routes.ts`: Placeholder router.
        * `server/src/server.ts`: Mount the main router under `/api` (e.g., `app.use('/api', mainRouter)`).
    * **Step Dependencies**: Step 9
    * **User Instructions**: None

* [ ] Step 11: Implement Core Middleware
    * **Task**: Add basic request logging middleware and a centralized error handling middleware.
    * **Files**:
        * `server/src/middleware/requestLogger.ts`: Simple middleware to log method and URL of incoming requests.
        * `server/src/middleware/errorHandler.ts`: Express error handling middleware (takes `err, req, res, next`). Logs the error and sends a standardized JSON error response (e.g., `{ success: false, error: { message: 'Internal Server Error' } }`). Catch specific Prisma errors if needed.
        * `server/src/server.ts`: Apply `requestLogger` middleware globally. Apply `errorHandler` middleware last.
    * **Step Dependencies**: Step 9
    * **User Instructions**: None

## Phase 3: Frontend Core Setup

* [ ] Step 12: Setup Basic Routing (React Router)
    * **Task**: Configure `react-router-dom` in `App.tsx` to handle basic page navigation. Create placeholder page components.
    * **Files**:
        * `client/src/App.tsx`: Wrap content in `<BrowserRouter>`. Define `<Routes>` with basic `<Route>` entries for home, models, evals, etc., linking to placeholder page components. Include layout structure.
        * `client/src/pages/HomePage.tsx`: Placeholder component.
        * `client/src/pages/ModelsPage.tsx`: Placeholder component.
        * `client/src/pages/EvalsListPage.tsx`: Placeholder component.
        * `client/src/pages/EvalGenerationPage.tsx`: Placeholder component.
        * `client/src/pages/ReportingPage.tsx`: Placeholder component.
        * `client/src/pages/NotFoundPage.tsx`: Placeholder 404 component.
    * **Step Dependencies**: Step 3
    * **User Instructions**: None

* [ ] Step 13: Implement Core Layout Components
    * **Task**: Create the main layout components: `Sidebar`, `Header` (optional), and `PageWrapper`. Integrate them into `App.tsx`.
    * **Files**:
        * `client/src/components/layout/Sidebar.tsx`: Basic sidebar structure with placeholder navigation links (`NavLink` from `react-router-dom`). Apply basic styling using CSS Modules.
        * `client/src/components/layout/PageWrapper.tsx`: Component that applies consistent padding/max-width to its children. Apply basic styling.
        * `client/src/components/layout/Sidebar.module.css`: Styles for Sidebar.
        * `client/src/components/layout/PageWrapper.module.css`: Styles for PageWrapper.
        * `client/src/App.tsx`: Structure the app layout (e.g., `<div style={{ display: 'flex' }}><Sidebar /><PageWrapper><Outlet /></PageWrapper></div>`).
    * **Step Dependencies**: Step 12
    * **User Instructions**: None

* [ ] Step 14: Setup Global Styles & Theme
    * **Task**: Define basic global styles and CSS variables for the theme (colors, fonts, spacing) specified in the design system.
    * **Files**:
        * `client/src/styles/global.css`: Include font imports (e.g., Inter from Google Fonts), reset/normalize styles, base body styles.
        * `client/src/styles/theme.css`: Define CSS custom properties (variables) for colors, spacing units, font families/sizes based on the spec.
        * `client/src/main.tsx`: Import `global.css` and `theme.css`.
    * **Step Dependencies**: Step 3
    * **User Instructions**: None

* [ ] Step 15: Create Common UI Components Stubs
    * **Task**: Create placeholder files and basic structure for common UI components (Button, Input, Modal, Spinner, ErrorMessage) with minimal styling. Define basic props using TypeScript interfaces.
    * **Files**:
        * `client/src/components/common/Button.tsx` / `.module.css`: Basic button structure, props interface.
        * `client/src/components/common/Input.tsx` / `.module.css`: Basic input structure, props interface.
        * `client/src/components/common/Modal.tsx` / `.module.css`: Basic modal structure (portal recommended), props interface.
        * `client/src/components/common/Spinner.tsx` / `.module.css`: Basic spinner element.
        * `client/src/components/common/ErrorMessage.tsx` / `.module.css`: Basic error display structure.
    * **Step Dependencies**: Step 14
    * **User Instructions**: None

* [ ] Step 16: Setup API Client & Query Provider
    * **Task**: Create a simple API client wrapper (using fetch or axios) for making requests to the backend. Setup TanStack Query provider.
    * **Files**:
        * `client/src/lib/api.ts`: Export functions for API calls (e.g., `getHealth()`). Include base URL (e.g., `http://localhost:3001/api`). Handle basic JSON response/error structure.
        * `client/src/main.tsx`: Initialize `QueryClient` and wrap `<App />` with `<QueryClientProvider>`.
    * **Step Dependencies**: Step 3, Step 9 (for backend URL)
    * **User Instructions**: Ensure the API base URL in `lib/api.ts` matches the backend port.

## Phase 4: Feature Implementation - Model Management

* [ ] Step 17: Backend - Create Model Endpoint
    * **Task**: Implement the `POST /api/models` route and the corresponding `createModel` controller function. Include basic validation (required fields, costs > 0). Fetch API key from env var based on `apiKeyEnvVar` field. Save to DB using Prisma.
    * **Files**:
        * `server/src/controllers/modelController.ts`: Implement `createModel` function. Add input validation logic. Use `prisma.model.create`. Handle potential Prisma unique constraint errors (duplicate name).
        * `server/src/routes/models.routes.ts`: Define `router.post('/', modelController.createModel)`.
    * **Step Dependencies**: Step 8, Step 10
    * **User Instructions**: Ensure relevant API keys are in your `.env` file.

* [ ] Step 18: Backend - Unit Test for Create Model
    * **Task**: Write a unit test for the `createModel` controller action, mocking Prisma and `process.env`.
    * **Files**:
        * `server/src/controllers/modelController.test.ts`: Add test suite for `createModel`, covering success case and validation failure cases. Use Jest/Vitest mocking.
    * **Step Dependencies**: Step 17
    * **User Instructions**: Ensure testing framework (Jest or Vitest) is configured for the server project.

* [ ] Step 19: Backend - Read Model Endpoints (Get All, Get One)
    * **Task**: Implement `GET /api/models` and `GET /api/models/:id` routes and corresponding controller functions (`getAllModels`, `getModelById`).
    * **Files**:
        * `server/src/controllers/modelController.ts`: Implement `getAllModels` and `getModelById` using `prisma.model.findMany` and `prisma.model.findUniqueOrThrow`. Handle not found errors.
        * `server/src/routes/models.routes.ts`: Define `router.get('/', modelController.getAllModels)` and `router.get('/:id', modelController.getModelById)`.
    * **Step Dependencies**: Step 8, Step 10
    * **User Instructions**: None

* [ ] Step 20: Frontend - Fetch and Display Models
    * **Task**: Implement data fetching in `ModelsPage` using TanStack Query (`useQuery`) to call the `GET /api/models` endpoint via `lib/api.ts`. Implement `ModelList` and `ModelListItem` to display the fetched data. Handle loading and error states.
    * **Files**:
        * `client/src/pages/ModelsPage.tsx`: Use `useQuery(['models'], api.getModels)` hook. Pass data/status to `ModelList`. Display `Spinner` or `ErrorMessage`. Add a button to trigger "Add Model".
        * `client/src/features/ModelManagement/ModelList.tsx`: Receive models array, map over it to render `ModelListItem`. Handle empty state.
        * `client/src/features/ModelManagement/ModelListItem.tsx`: Display model name, partial Base URL. Add placeholder Edit/Delete buttons.
        * `client/src/lib/api.ts`: Add `getModels()` and `getModelById(id)` functions.
        * `client/src/types/index.ts`: Define `Model` type interface matching backend structure (omit sensitive fields if any).
    * **Step Dependencies**: Step 15, Step 16, Step 19
    * **User Instructions**: None

* [ ] Step 21: Frontend - Add Model Form & Modal
    * **Task**: Implement the `ModelForm` component within a `Modal`. Manage form state using `useState`. Implement basic client-side validation.
    * **Files**:
        * `client/src/features/ModelManagement/ModelForm.tsx`: Create form layout using common components (`Input`). Manage state for each field. Add basic validation logic (e.g., required fields).
        * `client/src/pages/ModelsPage.tsx`: Add state to control modal visibility (`isModalOpen`, `setIsModalOpen`). Render the `Modal` containing `ModelForm` when `isModalOpen` is true. Pass `onClose` handler to Modal/Form.
        * `client/src/components/common/Modal.tsx`: Ensure modal logic (open/close, overlay click) is functional.
    * **Step Dependencies**: Step 15, Step 20
    * **User Instructions**: None

* [ ] Step 22: Frontend - Implement Add Model Functionality
    * **Task**: Use TanStack Query's `useMutation` hook in `ModelForm` to handle form submission. Call the `createModel` API function. Handle mutation status (loading, error, success). On success, close the modal and invalidate the 'models' query to refetch the list.
    * **Files**:
        * `client/src/features/ModelManagement/ModelForm.tsx`: Import and use `useMutation`. Add `onSubmit` handler. Call mutation's `mutate` function with form data. Display loading state on submit button. Display mutation error messages. Call `onClose` and `queryClient.invalidateQueries(['models'])` on success.
        * `client/src/lib/api.ts`: Add `createModel(data)` function.
    * **Step Dependencies**: Step 17, Step 21
    * **User Instructions**: None

* [ ] Step 23: Backend - Update & Delete Model Endpoints
    * **Task**: Implement `PUT /api/models/:id` and `DELETE /api/models/:id` routes and corresponding controller functions (`updateModel`, `deleteModel`). Include validation and dependency checks (optional for delete).
    * **Files**:
        * `server/src/controllers/modelController.ts`: Implement `updateModel` (validate input, use `prisma.model.update`) and `deleteModel` (use `prisma.model.delete`). Handle not found errors.
        * `server/src/routes/models.routes.ts`: Define `router.put('/:id', ...)`, `router.delete('/:id', ...)`.
    * **Step Dependencies**: Step 8, Step 10
    * **User Instructions**: None

* [ ] Step 24: Frontend - Implement Edit Model Functionality
    * **Task**: Add logic to open the `ModelForm` modal populated with existing model data when clicking the "Edit" button. Use `useMutation` to call the `updateModel` API on submit.
    * **Files**:
        * `client/src/pages/ModelsPage.tsx`: Add state to track the model being edited (`editingModel`). Pass this state to `ModelForm`.
        * `client/src/features/ModelManagement/ModelListItem.tsx`: Add `onClick` handler to Edit button, calling a function passed from `ModelsPage` to set `editingModel` and open the modal.
        * `client/src/features/ModelManagement/ModelForm.tsx`: Add `useEffect` to populate form state when `editingModel` prop changes. Conditionally call `api.updateModel` or `api.createModel` in `onSubmit` based on whether `editingModel` exists.
        * `client/src/lib/api.ts`: Add `updateModel(id, data)` function.
    * **Step Dependencies**: Step 22, Step 23
    * **User Instructions**: None

* [ ] Step 25: Frontend - Implement Delete Model Functionality
    * **Task**: Add a confirmation modal before deleting. Use `useMutation` to call the `deleteModel` API when the "Delete" button is clicked and confirmed.
    * **Files**:
        * `client/src/pages/ModelsPage.tsx`: Add state for confirmation modal and model to delete.
        * `client/src/features/ModelManagement/ModelListItem.tsx`: Add `onClick` handler to Delete button to open confirmation modal.
        * `client/src/components/common/ConfirmationModal.tsx`: Create a reusable confirmation modal component.
        * `client/src/pages/ModelsPage.tsx`: Implement `useMutation` hook for deletion. Call `mutate(modelId)` on confirmation. Handle loading/error. Invalidate 'models' query on success.
        * `client/src/lib/api.ts`: Add `deleteModel(id)` function.
    * **Step Dependencies**: Step 23, Step 24
    * **User Instructions**: None

## Phase 5: Feature Implementation - Core Services & Eval Generation

* [ ] Step 26: Backend - Implement LlmService (Basic Completion)
    * **Task**: Create `LlmService` with the `getLLMCompletion` function using `node-fetch` or `axios`. Implement basic request structure (OpenAI format), API key handling (from env var via Model config), basic response parsing (text completion), and error handling (network, non-2xx status).
    * **Files**:
        * `server/src/services/llmService.ts`: Implement the `getLLMCompletion` function as specified in the tech spec.
    * **Step Dependencies**: Step 8 (for Model type), Step 9
    * **User Instructions**: Ensure your `.env` file contains valid API keys referenced by the `apiKeyEnvVar` names you plan to use when creating `Model` entries.

* [ ] Step 27: Backend - Implement TokenizerService
    * **Task**: Create `TokenizerService` using the `gpt-tokenizer` library to implement `countTokens` and `isWithinTokenLimit` functions.
    * **Files**:
        * `server/src/services/tokenizerService.ts`: Import and use `gpt-tokenizer` functions.
    * **Step Dependencies**: Step 2 (install `gpt-tokenizer`)
    * **User Instructions**: None

* [ ] Step 28: Backend - Implement Cost Calculation Utility
    * **Task**: Create `costUtils.ts` with the `calculateCost` function based on model pricing and token counts.
    * **Files**:
        * `server/src/utils/costUtils.ts`: Implement the `calculateCost` function.
    * **Step Dependencies**: Step 8 (for Model type)
    * **User Instructions**: None

* [ ] Step 29: Backend - Eval Generation Endpoint
    * **Task**: Implement the `POST /api/evals/generate` route and the `generateEvalSet` controller function. Construct the prompt, call `LlmService`, parse the response (basic line splitting), and save the new `Eval` and associated `Question` records using Prisma.
    * **Files**:
        * `server/src/controllers/evalController.ts`: Implement `generateEvalSet` logic. Use `LlmService.getLLMCompletion`. Handle parsing errors. Use `prisma.eval.create` with nested `questions: { create: [...] }`.
        * `server/src/routes/evals.routes.ts`: Define `router.post('/generate', evalController.generateEvalSet)`.
    * **Step Dependencies**: Step 8, Step 10, Step 26
    * **User Instructions**: None

* [ ] Step 30: Frontend - Eval Generation Form UI
    * **Task**: Create the `EvalGenForm` component layout. Include fields for selecting the generator model (fetch models), prompt textarea, structured options (placeholders for now), and number of questions input. Manage form state.
    * **Files**:
        * `client/src/features/EvalGeneration/EvalGenForm.tsx`: Build form UI using common components. Fetch models using `useQuery` for the select dropdown. Manage local form state.
        * `client/src/pages/EvalGenerationPage.tsx`: Render the `EvalGenForm`.
    * **Step Dependencies**: Step 15, Step 20
    * **User Instructions**: None

* [ ] Step 31: Frontend - Implement Eval Generation API Call
    * **Task**: Use `useMutation` in `EvalGenForm` to call the `generateEvalSet` API endpoint on submit. Handle loading, error, and success states. On success, potentially navigate to the new eval's detail page (or show a success message).
    * **Files**:
        * `client/src/features/EvalGeneration/EvalGenForm.tsx`: Implement `useMutation` for the generation API call. Pass form data to the API function. Display loading/error feedback. Handle success (e.g., `Maps('/evals/' + createdEvalId)` using `useNavigate`).
        * `client/src/lib/api.ts`: Add `generateEvalSet(data)` function.
    * **Step Dependencies**: Step 29, Step 30
    * **User Instructions**: None

## Phase 6: Feature Implementation - Eval Management

* [ ] Step 32: Backend - Eval & Question CRUD Endpoints
    * **Task**: Implement basic CRUD endpoints for Evals (`GET /`, `GET /:id`, `PUT /:id`, `DELETE /:id`) and Questions (`PUT /:evalId/questions/:questionId`, `DELETE /:evalId/questions/:questionId`). Include basic filtering/searching for `GET /evals`.
    * **Files**:
        * `server/src/controllers/evalController.ts`: Add `getAllEvals` (with basic filtering by name/tags from query params), `getEvalById`, `updateEval` (metadata only), `deleteEval`.
        * `server/src/controllers/questionController.ts`: Create controller with `updateQuestion`, `deleteQuestion`.
        * `server/src/routes/evals.routes.ts`: Add routes for Eval CRUD. Add nested routes for questions (e.g., `router.put('/:evalId/questions/:questionId', questionController.updateQuestion)`).
    * **Step Dependencies**: Step 8, Step 10
    * **User Instructions**: None

* [ ] Step 33: Frontend - Evals List Page
    * **Task**: Implement the `EvalsListPage` to fetch and display a list of evals. Add basic search input and filter placeholders. Use TanStack Query for data fetching.
    * **Files**:
        * `client/src/pages/EvalsListPage.tsx`: Setup page, use `useQuery` to fetch evals (pass search/filter state). Include search input, filter placeholders. Render `EvalList`.
        * `client/src/features/EvalManagement/EvalList.tsx`: Display list of evals, link each item to detail page (`/evals/:id`).
        * `client/src/lib/api.ts`: Add `getEvals(params)` function.
        * `client/src/types/index.ts`: Define `Eval` type.
    * **Step Dependencies**: Step 12, Step 15, Step 16, Step 32
    * **User Instructions**: None

* [ ] Step 34: Frontend - Eval Detail Page Structure
    * **Task**: Create `EvalDetailPage` structure. Fetch eval details (including questions) using `useQuery` based on route param `:id`. Display metadata and the list of questions.
    * **Files**:
        * `client/src/pages/EvalDetailPage.tsx`: Get `id` from `useParams`. Use `useQuery(['eval', id], () => api.getEvalById(id))`. Display eval metadata (name, description, etc.). Render list of questions. Handle loading/error states.
        * `client/src/lib/api.ts`: Add `getEvalById(id)` function (ensure it includes questions).
        * `client/src/types/index.ts`: Update `Eval` type if needed, define `Question` type.
    * **Step Dependencies**: Step 12, Step 16, Step 32, Step 33
    * **User Instructions**: None

* [ ] Step 35: Frontend - Edit/Delete Questions
    * **Task**: Implement modals and API calls (`useMutation`) for editing question text and deleting questions from the `EvalDetailPage`. Invalidate eval detail query on success.
    * **Files**:
        * `client/src/pages/EvalDetailPage.tsx`: Add state/handlers for edit/delete modals. Implement mutations.
        * `client/src/features/EvalManagement/QuestionEditForm.tsx`: Form for editing question text.
        * `client/src/lib/api.ts`: Add `updateQuestion(evalId, questionId, data)` and `deleteQuestion(evalId, questionId)`.
    * **Step Dependencies**: Step 15, Step 32, Step 34
    * **User Instructions**: None

* [ ] Step 36: Backend - Tag Management Endpoints
    * **Task**: Implement endpoints for managing tags: creating tags, listing tags, associating tags with evals (`PUT /evals/:id/tags`).
    * **Files**:
        * `server/src/controllers/tagController.ts`: Create controller (`createTag`, `getAllTags`, `updateEvalTags`). Handle association logic using `EvalTags` join table (e.g., delete existing associations, create new ones).
        * `server/src/routes/tags.routes.ts`: Define routes for tags.
        * `server/src/routes/evals.routes.ts`: Add `router.put('/:id/tags', tagController.updateEvalTags)`.
    * **Step Dependencies**: Step 8, Step 10
    * **User Instructions**: None

* [ ] Step 37: Frontend - Tag Management UI
    * **Task**: Implement the `TagManager` component using a multi-select dropdown (consider library like `react-select`) to add/remove tags on the `EvalDetailPage`. Fetch available tags, allow creating new ones (optional V1), and call the API to update associations.
    * **Files**:
        * `client/src/features/EvalManagement/TagManager.tsx`: Component using multi-select. Fetch tags via `api.getTags`. Use `useMutation` to call `api.updateEvalTags`.
        * `client/src/pages/EvalDetailPage.tsx`: Integrate `TagManager`.
        * `client/src/lib/api.ts`: Add `getTags()`, `updateEvalTags(evalId, tagIds)`.
    * **Step Dependencies**: Step 34, Step 36
    * **User Instructions**: None

## Phase 7: Feature Implementation - Eval Execution

* [ ] Step 38: Backend - Eval Run Endpoint & Basic Logic
    * **Task**: Implement `POST /api/eval-runs` route and the `createEvalRun` controller function shell. Create the initial `EvalRun` record (status PENDING). Fetch eval questions and target model configs. Return run ID immediately.
    * **Files**:
        * `server/src/controllers/evalRunController.ts`: Implement `createEvalRun` basics. Use Prisma to create `EvalRun`. Fetch related data. *Don't implement the execution loop yet*.
        * `server/src/routes/evalRuns.routes.ts`: Define `router.post('/', evalRunController.createEvalRun)`.
    * **Step Dependencies**: Step 8, Step 10, Step 26
    * **User Instructions**: None

* [ ] Step 39: Backend - Asynchronous Eval Execution Logic
    * **Task**: Implement the core asynchronous execution loop within `createEvalRun` (or move to a separate async function called after returning the initial response). Use `Promise.allSettled` for parallel model calls per question. Call `LlmService`. Save `Response` records with text, error (if any), and link to run/question/model. Update `EvalRun` status to RUNNING then COMPLETED/FAILED.
    * **Files**:
        * `server/src/controllers/evalRunController.ts`: Implement the async loop logic. Use `LlmService`. Use `prisma.response.create`. Update `EvalRun` status. Implement robust error handling per response.
    * **Step Dependencies**: Step 26, Step 38
    * **User Instructions**: None

* [ ] Step 40: Backend - Token & Cost Saving in Execution
    * **Task**: Integrate `TokenizerService` and `CostUtils` into the eval execution loop to calculate and save token counts and estimated cost for each successful LLM response.
    * **Files**:
        * `server/src/controllers/evalRunController.ts`: Modify the loop to call `tokenizerService.countTokens` on prompt/response text. Call `costUtils.calculateCost` using model pricing. Save these values in the `Response` record.
    * **Step Dependencies**: Step 27, Step 28, Step 39
    * **User Instructions**: None

* [ ] Step 41: Frontend - Eval Run Configuration UI
    * **Task**: Create `EvalRunConfig` component. Allow selecting Eval set (if not already context). Provide multi-select checklist for Target LLMs (fetch models). Implement "Start Run" button.
    * **Files**:
        * `client/src/features/EvalExecution/EvalRunConfig.tsx`: Build UI. Fetch models for checklist. Manage selected models state. Add Start button.
        * `client/src/pages/EvalRunPage.tsx`: Render `EvalRunConfig` (or integrate into `EvalDetailPage`).
    * **Step Dependencies**: Step 15, Step 20
    * **User Instructions**: None

* [ ] Step 42: Frontend - Trigger Eval Run & Basic Progress
    * **Task**: Implement `useMutation` to call `api.createEvalRun` when "Start Run" is clicked. On success (receiving run ID), display a basic "Running..." message or `EvalRunProgress` component. (No real-time updates yet).
    * **Files**:
        * `client/src/features/EvalExecution/EvalRunConfig.tsx`: Implement `useMutation`. Call `api.createEvalRun`.
        * `client/src/pages/EvalRunPage.tsx` (or parent): Manage state to show progress indicator after run starts.
        * `client/src/features/EvalExecution/EvalRunProgress.tsx`: Basic component showing "Running..." or similar.
        * `client/src/lib/api.ts`: Add `createEvalRun(data)` function.
    * **Step Dependencies**: Step 38, Step 41
    * **User Instructions**: None

* [ ] Step 43: Backend - Get Eval Run Results Endpoint
    * **Task**: Implement an endpoint `GET /api/eval-runs/:id/results` to fetch details of a completed run, including all associated responses with their scores (if any).
    * **Files**:
        * `server/src/controllers/evalRunController.ts`: Add `getEvalRunResults` function. Use Prisma to find `EvalRun` and include related `Responses` (and their `Scores`).
        * `server/src/routes/evalRuns.routes.ts`: Define `router.get('/:id/results', ...)`.
    * **Step Dependencies**: Step 8, Step 10
    * **User Instructions**: None

* [ ] Step 44: Frontend - Display Eval Run Results Table
    * **Task**: Create `EvalResultsTable` component. Fetch results using `useQuery` and the run ID. Display questions, responses per model, tokens, cost, and errors in a structured table.
    * **Files**:
        * `client/src/features/EvalExecution/EvalResultsTable.tsx`: Implement table structure. Fetch data using `useQuery`. Map data to rows/columns.
        * `client/src/pages/EvalRunPage.tsx` (or results page): Render `EvalResultsTable` when run is complete (requires status check or separate results route).
        * `client/src/lib/api.ts`: Add `getEvalRunResults(id)` function.
        * `client/src/types/index.ts`: Define `EvalRun`, `Response` types.
    * **Step Dependencies**: Step 15, Step 43, Step 42 (to know when to fetch/display)
    * **User Instructions**: None

## Phase 8: Feature Implementation - Response Scoring

* [ ] Step 45: Backend - Manual Scoring Endpoint
    * **Task**: Implement `POST /api/scores/manual` route and `addManualScore` controller function. Upsert score into the `Score` table linked to the `Response`.
    * **Files**:
        * `server/src/controllers/scoreController.ts`: Create controller. Implement `addManualScore`. Use `prisma.score.upsert`.
        * `server/src/routes/scores.routes.ts`: Create file. Define `router.post('/manual', scoreController.addManualScore)`.
        * `server/src/routes/index.ts`: Mount scores router.
    * **Step Dependencies**: Step 8, Step 10
    * **User Instructions**: None

* [ ] Step 46: Frontend - Manual Scoring UI Integration
    * **Task**: Integrate `ManualScoreInput` component into `EvalResultsTable`. Use `useMutation` to call `api.addManualScore` when a score is set. Update UI optimistically or refetch results.
    * **Files**:
        * `client/src/features/ResponseScoring/ManualScoreInput.tsx`: Create component (e.g., rating buttons). Props: `responseId`, `currentScore`, `onChange`.
        * `client/src/features/EvalExecution/EvalResultsTable.tsx`: Render `ManualScoreInput` per response. Implement mutation logic, calling `api.addManualScore`. Invalidate results query on success.
        * `client/src/lib/api.ts`: Add `addManualScore(data)` function.
        * `client/src/types/index.ts`: Define `Score` type.
    * **Step Dependencies**: Step 15, Step 44, Step 45
    * **User Instructions**: None

* [ ] Step 47: Backend - LLM Scoring Endpoint & Logic
    * **Task**: Implement `POST /api/scores/llm` route and `triggerLlmScoring` controller function. Implement async logic to loop through responses, construct prompts for the scoring LLM, call `LlmService`, parse results, and upsert `Score` records.
    * **Files**:
        * `server/src/controllers/scoreController.ts`: Implement `triggerLlmScoring` async logic. Use `LlmService`. Handle parsing of score/justification from LLM response. Use `prisma.score.upsert`.
        * `server/src/routes/scores.routes.ts`: Define `router.post('/llm', ...)`.
    * **Step Dependencies**: Step 8, Step 10, Step 26, Step 45
    * **User Instructions**: None

* [ ] Step 48: Frontend - LLM Scoring Configuration & Trigger
    * **Task**: Create `LLMScoreConfig` modal/component. Allow selecting scorer LLM and inputting scoring prompt. Use `useMutation` to call `api.triggerLlmScoring`. Display progress/completion feedback.
    * **Files**:
        * `client/src/features/ResponseScoring/LLMScoreConfig.tsx`: Build UI (model select, textarea). Fetch models. Implement mutation.
        * `client/src/pages/EvalRunPage.tsx` (or results view): Add button to open `LLMScoreConfig` modal. Display scoring status feedback.
        * `client/src/lib/api.ts`: Add `triggerLlmScoring(data)` function.
    * **Step Dependencies**: Step 15, Step 20, Step 44, Step 47
    * **User Instructions**: None

* [ ] Step 49: Frontend - Display Scores
    * **Task**: Update `EvalResultsTable` and create `ScoreDisplay` component to show the score (manual or LLM), justification (if LLM), and scorer info retrieved from the API.
    * **Files**:
        * `client/src/features/ResponseScoring/ScoreDisplay.tsx`: Component to render score details.
        * `client/src/features/EvalExecution/EvalResultsTable.tsx`: Fetch scores along with responses (modify `getEvalRunResults` if needed). Pass score data to `ScoreDisplay`.
        * `server/src/controllers/evalRunController.ts`: Ensure `getEvalRunResults` includes `Score` data linked to `Response`.
    * **Step Dependencies**: Step 44, Step 46, Step 48
    * **User Instructions**: None

## Phase 9: Feature Implementation - Judge Mode

* [ ] Step 50: Backend - Judge Mode Endpoint & Logic
    * **Task**: Implement `POST /api/judgments` route and `triggerJudging` controller function. Implement async logic to loop through questions, call selected Judge LLMs via `LlmService` with appropriate prompts, parse results, and save `Judgment` records.
    * **Files**:
        * `server/src/controllers/judgmentController.ts`: Create controller. Implement `triggerJudging` async logic. Use `LlmService`. Parse judgment scores/justification. Use `prisma.judgment.create`.
        * `server/src/routes/judgments.routes.ts`: Create file. Define `router.post('/', judgmentController.triggerJudging)`.
        * `server/src/routes/index.ts`: Mount judgments router.
    * **Step Dependencies**: Step 8, Step 10, Step 26
    * **User Instructions**: None

* [ ] Step 51: Frontend - Judge Mode Configuration & Trigger
    * **Task**: Create `JudgeModeConfig` component (modal/section on `EvalDetailPage`). Allow selecting Judge LLM(s) and configuring criteria/prompt. Use `useMutation` to call `api.triggerJudging`. Provide feedback.
    * **Files**:
        * `client/src/features/JudgeMode/JudgeModeConfig.tsx`: Build UI (model multi-select, criteria options/textarea). Fetch models. Implement mutation.
        * `client/src/pages/EvalDetailPage.tsx`: Add button to open `JudgeModeConfig`. Display judging status feedback.
        * `client/src/lib/api.ts`: Add `triggerJudging(data)` function.
    * **Step Dependencies**: Step 15, Step 20, Step 34, Step 50
    * **User Instructions**: None

* [ ] Step 52: Backend - Get Judgments Endpoint
    * **Task**: Implement an endpoint (e.g., `GET /api/evals/:id/judgments`) to fetch all judgments associated with an eval's questions.
    * **Files**:
        * `server/src/controllers/judgmentController.ts`: Add `getJudgmentsForEval` function. Use Prisma to find judgments linked to questions of the specified eval.
        * `server/src/routes/evals.routes.ts`: Define `router.get('/:id/judgments', ...)`.
    * **Step Dependencies**: Step 8, Step 10
    * **User Instructions**: None

* [ ] Step 53: Frontend - Display Judge Mode Results
    * **Task**: Create `JudgeResultsDisplay` component. Fetch judgments using `useQuery`. Display questions alongside ratings/justifications from different judges. Integrate into `EvalDetailPage`.
    * **Files**:
        * `client/src/features/JudgeMode/JudgeResultsDisplay.tsx`: Fetch judgments. Group/display results per question, showing judge ratings.
        * `client/src/pages/EvalDetailPage.tsx`: Render `JudgeResultsDisplay`.
        * `client/src/lib/api.ts`: Add `getJudgmentsForEval(evalId)` function.
        * `client/src/types/index.ts`: Define `Judgment` type.
    * **Step Dependencies**: Step 15, Step 34, Step 51, Step 52
    * **User Instructions**: None

## Phase 10: Feature Implementation - Reporting

* [ ] Step 54: Backend - Reporting Endpoints (Leaderboard, Costs)
    * **Task**: Implement endpoints for aggregated reports (e.g., `GET /api/reports/leaderboard`, `GET /api/reports/costs`). Use Prisma aggregation features (`groupBy`, `_avg`, `_sum`) to calculate metrics based on `Responses`, `Scores`, `Judgments`.
    * **Files**:
        * `server/src/controllers/reportController.ts`: Create controller. Implement functions like `getLeaderboardData`, `getCostReportData`. Perform Prisma aggregations. Format results.
        * `server/src/routes/reports.routes.ts`: Define routes.
    * **Step Dependencies**: Step 8, Step 10
    * **User Instructions**: None

* [ ] Step 55: Frontend - Reporting Page & Leaderboard
    * **Task**: Create `ReportingPage`. Implement `Leaderboard` component. Fetch leaderboard data using `useQuery` and display in a table.
    * **Files**:
        * `client/src/pages/ReportingPage.tsx`: Setup page structure.
        * `client/src/features/Reporting/Leaderboard.tsx`: Fetch data via `api.getLeaderboardData`. Display in a `Table` component.
        * `client/src/lib/api.ts`: Add `getLeaderboardData()` function.
        * `client/src/components/common/Table.tsx`: Ensure table component is functional.
    * **Step Dependencies**: Step 12, Step 15, Step 16, Step 54
    * **User Instructions**: None

* [ ] Step 56: Frontend - Cost & Token Reporting
    * **Task**: Implement `CostReport` and `TokenUsageChart` components. Fetch relevant aggregated data (`api.getCostReportData`, potentially another for token data or calculate client-side). Display using tables and charts (using `recharts` or similar).
    * **Files**:
        * `client/src/features/Reporting/CostReport.tsx`: Fetch cost data. Display in table/chart.
        * `client/src/features/Reporting/TokenUsageChart.tsx`: Fetch/process data. Display using a chart library.
        * `client/src/pages/ReportingPage.tsx`: Integrate these components.
        * `client/src/lib/api.ts`: Add `getCostReportData()` function.
        * `client/`: Install and configure a charting library like `recharts`.
    * **Step Dependencies**: Step 16, Step 54, Step 55
    * **User Instructions**: Install `recharts` (`npm install recharts` in `client/`).

## Phase 11: Testing

* [ ] Step 57: Backend Unit Tests (Remaining Features)
    * **Task**: Add unit tests for controllers implemented in Phases 6-10 (Eval, Question, Tag, EvalRun, Score, Judgment, Report controllers), mocking services and Prisma where necessary.
    * **Files**:
        * `server/src/controllers/*.test.ts`: Add comprehensive tests covering success and failure cases for remaining controller actions.
    * **Step Dependencies**: Steps covering controller implementations.
    * **User Instructions**: Run tests using `npm test` (or configured script) in `server/`.

* [ ] Step 58: Frontend Component Tests
    * **Task**: Add basic rendering and interaction tests using React Testing Library for key components implemented (Forms, Tables, ListItems, Modals, Feature-specific components). Mock API calls using `msw` or jest mocks.
    * **Files**:
        * `client/src/features/**/*.test.tsx`: Add tests for components.
        * `client/src/components/common/*.test.tsx`: Add tests for common components.
    * **Step Dependencies**: Steps covering frontend component implementations.
    * **User Instructions**: Run tests using `npm test` (or configured script) in `client/`. Setup testing library and mocks if not already done.

* [ ] Step 59: E2E Tests - Setup & Core Flows
    * **Task**: Setup Playwright/Cypress for E2E testing. Implement tests for core workflows: Model CRUD, basic Eval Generation.
    * **Files**:
        * `e2e/` (or similar directory): Setup test runner config (e.g., `playwright.config.ts`).
        * `e2e/tests/models.spec.ts`: Test Model CRUD flow.
        * `e2e/tests/eval-generation.spec.ts`: Test creating an eval.
    * **Step Dependencies**: Fully implemented Model Management and Eval Generation features.
    * **User Instructions**: Install Playwright/Cypress (`npm install --save-dev @playwright/test` or `npm install --save-dev cypress`). Configure base URL etc.

* [ ] Step 60: E2E Tests - Execution & Reporting Flows
    * **Task**: Implement E2E tests for Eval Execution, viewing results, manual scoring, judging (basic trigger), and viewing the reporting page.
    * **Files**:
        * `e2e/tests/eval-execution.spec.ts`: Test configuring and running an eval, checking for results display.
        * `e2e/tests/scoring.spec.ts`: Test applying a manual score.
        * `e2e/tests/judging.spec.ts`: Test triggering judge mode.
        * `e2e/tests/reporting.spec.ts`: Test navigating to and viewing the reporting page.
    * **Step Dependencies**: Relevant features fully implemented. Step 59.
    * **User Instructions**: Run E2E tests (e.g., `npx playwright test`).

## Phase 12: Polish & Documentation

* [ ] Step 61: Final UI/UX Review & Polish
    * **Task**: Review the entire application for UI consistency, usability, responsiveness, loading states, error handling feedback, and overall user experience. Make necessary CSS and component adjustments.
    * **Files**: Various `.tsx` and `.module.css` files across the `client/` directory.
    * **Step Dependencies**: All feature implementation steps.
    * **User Instructions**: None

* [ ] Step 62: Update README
    * **Task**: Update the main `README.md` with setup instructions, how to run the client and server, environment variable explanations, and a brief overview of the application.
    * **Files**:
        * `README.md`: Add detailed documentation.
    * **Step Dependencies**: All steps.
    * **User Instructions**: None

---

**Summary & Key Considerations:**

This plan provides a sequential breakdown for building the "MyModelArena" application. It starts with foundational setup, builds the backend API layer by layer, develops the corresponding frontend features, and integrates testing throughout.

* **Iterative Development:** Each step represents a small, manageable unit of work suitable for an AI code generator or a human developer.
* **Backend First (Mostly):** For most features, the backend API is implemented before the frontend UI that consumes it, ensuring the data layer is ready.
* **Dependencies:** The plan explicitly considers dependencies between steps.
* **Testing:** Unit tests are planned alongside backend/frontend logic implementation, while E2E tests provide workflow validation later.
* **User Instructions:** Manual steps like `.env` configuration and running migrations are highlighted.
* **Flexibility:** While sequential, some parallelization might be possible (e.g., developing different frontend feature components once core layout/API client is ready), but this plan assumes a primarily linear flow for clarity.
* **Error Handling:** Is integrated into backend controllers and frontend API call handling (`useMutation`/`useQuery`). Specific edge case handling within business logic should be addressed during implementation of relevant steps.
* **Async Nature:** Steps involving LLM calls are designed to be asynchronous, and frontend steps need to handle the resulting loading/pending states.
* **Complexity:** Features like Eval Execution, LLM Scoring, and Judging involve complex asynchronous operations and potentially tricky LLM response parsing; these steps may require more careful implementation and testing.